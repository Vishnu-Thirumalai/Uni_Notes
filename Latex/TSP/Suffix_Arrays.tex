\section{Suffix Arrays}
Most algorithms so far have dealt with pre-processing a single pattern, so it can be searched for in various texts. Often however, we'll have a single text that we want to search for different patterns. This problem is called \textbf{Text Indexing}.\\ \\
Karp-Robin or Suffix Trees can work for this, but a more efficient way is to use \emph{Suffix Arrays}. These are lexographically sorted lists of the suffixes of a string: any pattern/substring that is present in the string will be a prefix for one of these suffixes. Rather than directly storing the suffixes (a huge amount of space), the array instead stores an index i, representing string $x[i:]$. \\ \\
Since this is a sorted array, we can just use a modified binary search or an LCP search that checks if the pattern P is a prefix for the suffixes: if we use the interval method, this gives us a list of occurrences of P in the string. \\
With storage and searching out of the way, the most time-consuming part is constructing the suffix array. Naively for a string s, this could take $O(|s|^2log|s|)$, but this can be reduced to $O(|s|)$.  For the algorithms, n is $|s$.

\subsection{Algorithm Groundwork}

\subsubsection{Radix Sort}
Using a Radix Sort, a sequence of n numbers with k possible numbers (e.g all the numbers are in the range $(1\dots k)$ can be sorted in O(n+k). This also applies to pairs of numbers.\\
Radix Sort works by considering each index of the number individually, then using Bucket/Counting sort (Make a 'bucket' for each possible value, put the numbers in the corresponding bucket, append all the buckets together) to sort them. If done from the lowest to highest index (Least Significant) this is a stable sort, but highest to lowest (most Significant) is usually faster. 

\subsubsection{Merging Arrays} \label{subsubsec:Merging_Arrays}
Two sorted arrays A and B can be merged into a single sorted array in $O(|A|+|B|)$, as below:
\textbf{Merge(A,B)}:
\begin{enumerate}[label=\Alph*]
    \item i=0, j=0, a=0, b=0, C = []
    \item while \( i+j < |A|+|B|\):
\begin{enumerate}[label=\arabic*]
    \item a = A[i] \emph{(If out of bounds, a = max\_value)}
    \item b = B[i] \emph{(If out of bounds, b = max\_value)}
    \item if \(a < b\):
    \begin{enumerate}
        \item C.append(a)
        \item i++
    \end{enumerate}      
    \item [] else:
    \begin{enumerate}
        \item C.append(b)
        \item j++
    \end{enumerate}      
\end{enumerate}    
\end{enumerate}
Effectively, check the current position of each array, append the lower to c, then increment that array's position by 1. This can be made more efficient by stopping when one of the arrays is exhausted and simply appending the other array.

\subsection{$O(n^2)$ Algorithm}
This algorithm is similar to Least Significant Radix Sort, in that it sorts the population by only considering one index and using the ordering of the sorted substrings to resolve conflicts. To simplify, head(s) refers to the first character of s, and tail(s) refers to s[1:]. \\ \\
At each iteration, the algorithm generates a sorted list of substrings. Rather than performing a full sort each time, the algorithm generates a pair for each substring w: the first element is (int) head(w), the second is the index of tail(w) in the previous iteration's list. This list of pairs is sorted, converted back to strings, then used in the next generation. If a substring wasn't present in the previous list, it's given a default value of 0. \\ \\
To convert a char to int, a custom list is made for the language (e.g. $\sum$=(a,g,t)$\rightarrow$A:1,G:2,T:3). The algorithm uses previous orderings to sort, so only the head is considered at each generation which makes it more efficient, but it still sorts the list n (=$|s|$) times. \\ \\
\textbf{SuffixArray(s)}:
\begin{enumerate}[label=\Alph*]
    \item for i in range(n-1, 0):
\begin{enumerate}[label=\arabic*]
    \item $L_i = []$
    \item for j in range(i,n-1): \emph{(Generate $L_i$)}
    \begin{enumerate}
        \item [] $L_i$.append((int)w[j], idx($L_{i+1}$, w[j+1$\dots |s|-1$]))
    \end{enumerate} 
    \item Sort $L_i$ 
\end{enumerate}    
    \item Return $L_0$
\end{enumerate}

\subsection{$O(nlog(n))$ Algorithm}
This is similar to the above, but rather than one letter at a time it doubles the length of the strings to sort in each generation (therefore taking it to $log_2(n)$ from n generations). To include all substrings, the length of the string is first doubled by adding $|s|$ null characters (any character not in the alphabet, such as \$). \\
The pair is generated by halving the strings at each generation, and using the indices of each half from the previous generation. Again, if a substring wasn't present in the previous list it's given a default value of 0 (this will only happen if it started with \$, which comes before all characters in $\sum$). \\ \\
\textbf{SuffixArray(s)}:
\begin{enumerate}[label=\Alph*]
    \item n = $|s|$, Append $|s|$ \$ to s , i = 2
    \item $L_1 = \sum$ \emph{($L_1$ is just sorted individual characters)}
    \item while $i\leq n$:
\begin{enumerate}[label=\arabic*]
    \item ss = []
    \item for j in range(0,n): \emph{(Add all unique substrings of len i that don't start with \$)}
    \begin{enumerate}
        \item x = s[j:j+1] 
        \item if x not in ss \textbf{and} x[0] $\neq$ \$:
        \item [] \quad ss.append(x)
    \end{enumerate}     
    \item $L_i = []$
    \item for j in range(0, len(ss)): \emph{(Construct pairs)}
    \begin{enumerate}
        \item a = ss[j][0:i/2], b=ss[j][i/2:] \emph{(Split each string into half)}
        \item $L_i$.append(idx($L_{i/2}$, a), idx($L_{i/2}$, b))
    \end{enumerate} 
    \item Sort $L_i$ 
    \item i *= 2
\end{enumerate}    
    \item Return $L_0$
\end{enumerate}

\subsection{O(n) Algorithm (DC3 Algorithm)}
Original paper: https://www.cs.helsinki.fi/u/tpkarkka/publications/jacm05-revised.pdf. This version slightly deviates from the original, but is still O(n).\\ \\
The suffixes for s are split into 3 groups: $S_0$, $S_1$ and $S_2$. $S_0$ and $S_1 \cup S_2$ are sorted independently (so a 1/3 and 2/3 split), then merged back together. Sorting is done by creating triples in the strings, ranking each triple, and using them to rank the strings. To ensure that the triples are created properly, \$\$ (or another null character) is appended to S.        

\subsubsection{Splitting the Substrings}
Substrings are added to each group in order. i.e s[0:] $\rightarrow S_0$, s[1:] $\rightarrow S_1$, s[2:] $\rightarrow S_2$, s[3:] $\rightarrow S_0 \dots$. The two substrings starting with \$ are ignored, so the groups may not be the same size, but the smallest substring has length=3. e.g
\begin{align}
    S &= aabbbab\$\$ \nonumber \\
    S_0 &= [aabbbab\$\$, bbab\$\$, b\$\$ ] \nonumber \\
    S_1 &= [abbbab\$\$, bab\$\$] \nonumber \\
    S_2 &= [bbbab\$\$, ab\$\$] \nonumber 
\end{align}

\subsubsection{Sorting $S_0$}
The largest substring (index 0, which is equal to s), is split into groups of 3 characters. These triples are ranked, converting them to integers. Using these integers, each string in $S_0$ is converted to a string of integers. These are used to sort $S_0$ using MS radix sort. \\
e.g.
\begin{align}
    S_0 &= [aabbbab\$\$, bbab\$\$, b\$\$ ] \nonumber \\
    aab&|bba|b\$\$ \nonumber \\
     1\; &|\;\;3\;|\;\; 2\,  \nonumber \\
    I_0 &= [132, 32, 2] \nonumber \\
    sorted(I_0) &= [132, 2, 32] \nonumber \\
    sorted(S_0) &= [aabbbab\$\$, b\$\$, bbab\$\$ ] \nonumber 
\end{align}

\subsubsection{Sorting $S_1 \cup S_2$}
Same as sorting $S_0$, except the substring used is $S_1[0]S_2[0]$, and the integers for $S_1$ all have $I_2[0]$ appended to them (effectively, each string has the integer string that it's the prefix for).e.g.
\begin{align}
    S_1 \cup S_2 &= [abbbab\$\$, bab\$\$, bbbab\$\$, ab\$\$] \nonumber \\
    abb&|bab|bbb|ab\$ \nonumber \\
     2\; &|\;\;3\;|\;\;4\;|\;\;1  \nonumber \\
    I_{12} &= [2341,341,41,1] \nonumber \\
    sorted(I_{12}) &= [1,2341,341,41] \nonumber \\
    sorted(S_1 \cup S_2) &= [ab\$\$, abbbab\$\$, bab\$\$, bbbab\$\$] \nonumber 
\end{align}

\subsubsection{Merging $S_0$ and $S_1 \cup S_2$}
This is a standard merge, as in \ref{subsubsec:Merging_Arrays}. Rather than comparing the strings directly (which would make the merge $O(|s|^2)$), the strings are converted into tuples using the sorted $S_1 \cup S_2$ (henceforth referred to as $S_{12}$), and these are compared. The tuples vary based on if the considered string belongs to $S_1$ or $S_2$:
\begin{itemize}
    \item The considered string from $S_0$ is $C_a$, from $S_{12}$ is $C_b$, idx(x,y) is the index of y in x
    \item $C_b$ belongs to $S_1$:
    \begin{itemize}
        \item Compare ($C_a[0]$, idx($S_{12}$,$C_a[1:]$)) and ($C_b[0]$, idx($S_{12}$,$C_b[1:]$))
    \end{itemize}
    \item $C_b$ belongs to $S_2$:
    \begin{itemize}
        \item Compare ($C_a[0]$, $C_a[1]$, idx($S_{12}$,$C_a[2:]$)) and ($C_b[0]$, $C_b[1]$, idx($S_{12}$,$C_b[2:]$))
    \end{itemize}    
\end{itemize}

\subsubsection{Algorithm}
\textbf{SuffixArray(s)}:
\begin{enumerate}[label=\Alph*]
    \item n = $|s|$, Append \$ \$ to s , $S$ = [[],[],[]]
    \item for i in range(0,n-1):
    \begin{enumerate}
        \item [] S[i\%3].append(s[i:])
    \end{enumerate}
    \item Sort S[0]
    \item R = S[1].extend(S[2])
    \item Sort R
    \item i=0, j=0, a = 0, b = 0, C = []
    \item while \( i<|S[0]| and j<|R|\):
\begin{enumerate}[label=\arabic*]
    \item if R[j] $\in$ S[1]:
    \begin{enumerate}
        \item a = (S[0][i][0], R.idx(S[0][i][1:]))
        \item b = (R[j][0], R.idx(R[j][1:]))
    \end{enumerate}
    \item [] else :
    \begin{enumerate}
        \item a = (S[0][i][0], S[0][i][1],  R.idx(S[0][i][2:]))
        \item b = (R[j][0], R[j][1], R.idx(R[j][2:]))
    \end{enumerate}    
    \item if \(a < b\):
    \begin{enumerate}
        \item C.append(a)
        \item i++
    \end{enumerate}      
    \item [] else:
    \begin{enumerate}
        \item C.append(b)
        \item j++
    \end{enumerate}      
\end{enumerate}   
\item if \(i < |S[0]| \): \emph{(If S[0] didn't finish)}
\begin{enumerate}
    \item C.append(S[0][i:])
\end{enumerate}
\item[] else: \emph{(If R didn't finish)}
\begin{enumerate}
    \item C.append(R[j:])
\end{enumerate}
\item return C
\end{enumerate}    

\newpage 
\subsection{Suffix Inverse Array}
If the suffix array is denoted as SA, SA$^{-1}$ is the suffix inverse array: for a string w, SA$^-1$[i] is the position of w[i:] in SA. Essentially, it's the rank of a substring in the suffix array.

\subsection{Longest Common Prefix Array}
The LCP array for a Suffix Array (SA) is an array of the length of the LCP between each adjacent suffix.
\begin{align}
    LCP[0]&=0 \nonumber \\
    LCP[i]&=lcp(SA[i],SA[i-1]) \nonumber 
\end{align}
Since SA is lexicographically sorted, any common prefix between SA[i] and SA[j] is also common for any SA[k] where $k \in (i,j)$. This can be trivially found by finding the minimum value of LCP[k]. Using this, we can find the common prefix between any two suffixes of a string: use SA$^{-1}$ to find the positions in SA, then find the minimum in the LCP. To generate the array in O(n): \\ \\
\textbf{LCPArray(s)}
\begin{enumerate}[label=\Alph*]
    \item $l$ = 0
    \item for i in range(0,n-1)
    \begin{enumerate}[label=\arabic*]
        \item k = SA$^{-1}$[i], j = SA[k-1] \emph{(j is the start idx of the substring before s[i:] in SA)}
        \item while s[i+l] =s[j+1]:
        \item[] \quad $l$++
        \item LCP[k] = $l$
        \item $l$ = max($l$-1,0) \emph{(LCP[i]-1 is $\leq$ LCP[i+1])}
    \end{enumerate}
\end{enumerate}



